package dockerit

import (
	"context"
	"github.com/docker/docker/api/types"
	typesContainer "github.com/docker/docker/api/types/container"
	typesFilters "github.com/docker/docker/api/types/filters"
	typesStrslice "github.com/docker/docker/api/types/strslice"
	"github.com/docker/docker/client"
	"github.com/docker/docker/pkg/stringid"
	"github.com/docker/go-connections/nat"
	"io"
	"io/ioutil"
)

type dockerClient struct {
	client *client.Client
}

// newDockerClient initializes a new API docker.NewEnvClient client based on environment variables.
// Use DOCKER_HOST to set the url to the docker server.
// Use DOCKER_API_VERSION to set the version of the API to reach, leave empty for latest.
// Use DOCKER_CERT_PATH to load the TLS certificates from.
// Use DOCKER_TLS_VERIFY to enable or disable TLS verification, off by default.
func newDockerClient() (*dockerClient, error) {
	cli, err := client.NewEnvClient()
	if err != nil {
		return nil, err
	}
	return &dockerClient{client: cli}, nil
}

// Close ensures that docker client transport is closed
func (r *dockerClient) Close() error {
	return r.client.Close()
}

// GetContainerByID returns the container from the docker host.
func (r *dockerClient) GetContainerByID(containerID string) (*types.Container, error) {
	options := types.ContainerListOptions{All: true}
	containers, err := r.client.ContainerList(context.Background(), options)
	if err != nil {
		return nil, err
	}
	for _, container := range containers {
		if container.ID == containerID {
			return &container, nil
		}
	}
	return nil, nil
}

// GetImageByName returns first image for a given name from a list of images in the docker host.
func (r *dockerClient) GetImageByName(imageName string) (*types.ImageSummary, error) {
	// https://docs.docker.com/engine/api/v1.29/#operation/ImageList
	imageFilters := typesFilters.NewArgs()
	imageFilters.Add("reference", imageName)
	options := types.ImageListOptions{All: false, Filters: imageFilters}

	summaries, err := r.client.ImageList(context.Background(), options)
	if err != nil {
		return nil, err
	}
	if len(summaries) != 0 {
		return &summaries[0], nil
	}
	return nil, nil
}

// RemoveImageByName removes all images for a given name in the docker host.
func (r *dockerClient) RemoveImageByName(imageName string) error {
	// https://docs.docker.com/engine/api/v1.29/#operation/ImageList
	imageFilters := typesFilters.NewArgs()
	imageFilters.Add("reference", imageName)
	options := types.ImageListOptions{All: false, Filters: imageFilters}
	summaries, err := r.client.ImageList(context.Background(), options)
	if err != nil {
		return err
	}
	for _, summary := range summaries {
		if err = r.RemoveImage(summary.ID); err != nil {
			return err
		}
	}
	return nil
}

// RemoveImage removes an image from the docker host.
func (r *dockerClient) RemoveImage(imageID string) error {
	options := types.ImageRemoveOptions{Force: true}
	_, err := r.client.ImageRemove(context.Background(), imageID, options)
	return err

}

// PullImage requests the docker host to pull an image from a remote registry.
func (r *dockerClient) PullImage(imageName string) error {
	options := types.ImagePullOptions{}
	resp, err := r.client.ImagePull(context.Background(), imageName, options)
	if err != nil {
		return err
	}
	_, err = ioutil.ReadAll(resp)
	if err != nil {
		return err
	}
	return nil
}

// CreateContainer creates a new container.
func (r *dockerClient) CreateContainer(containerName string, image string, env []string, portSpecs []string, cmd []string, binds []string) (string, error) {
	// ip:public:private/proto
	exposedPorts, portBindings, err := nat.ParsePortSpecs(portSpecs)
	if err != nil {
		return "", err
	}
	config := typesContainer.Config{
		Image:        image,
		Env:          env,
		ExposedPorts: exposedPorts,
		Cmd:          typesStrslice.StrSlice(cmd),
	}
	hostConfig := typesContainer.HostConfig{
		PortBindings: portBindings,
		Binds:        binds,
	}

	body, err := r.client.ContainerCreate(context.Background(), &config, &hostConfig, nil, containerName)
	if err != nil {
		return "", err
	}
	// return container ID
	return body.ID, nil
}

// StartContainer sends a request to the docker daemon to start a container.
func (r *dockerClient) StartContainer(containerID string) error {
	options := types.ContainerStartOptions{}
	return r.client.ContainerStart(context.Background(), containerID, options)
}

// ContainerLogs returns the logs generated by a container in an io.ReadCloser.
func (r *dockerClient) ContainerLogs(containerID string, follow bool) (io.ReadCloser, error) {
	options := types.ContainerLogsOptions{ShowStdout: true, ShowStderr: true, Follow: follow}
	return r.client.ContainerLogs(context.Background(), containerID, options)
}

// StopContainer stops a container without terminating the process.
func (r *dockerClient) StopContainer(containerID string) error {
	return r.client.ContainerStop(context.Background(), containerID, nil)
}

// RemoveContainer kills and removes a container from the docker host.
func (r *dockerClient) RemoveContainer(containerID string) error {
	options := types.ContainerRemoveOptions{RemoveVolumes: true, Force: true}
	return r.client.ContainerRemove(context.Background(), containerID, options)
}

// TruncateID returns a shorthand version of a string identifier.
func TruncateID(id string) string {
	return stringid.TruncateID(id)
}
